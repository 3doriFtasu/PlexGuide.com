drives_deploy() {

drives_menu_start_setup

if [[ -e "/pg/var/drives/gd/token.info" ]]; then
  gdcheck=$(cat /pg/var/drives/gd/token.info)
    if [[ "$gdcheck" == "VALID" ]]; then
      gdr_check=$(rclone lsd --config /pg/var/drives/gd/gd.conf gd: | grep "plexguide.com")
      if [[ "$gdr_check" != "" ]]; then common_header "ðŸ’¾  PASSED:  Unencrypted Token gd is [VALID]"
        if [[ -e "/pg/var/drives/gd/token.encrypted" ]]; then
          gdrc_check=$(rclone lsd --config /pg/var/drives/gd/gd.conf gdc: | grep "plexguide.com")
          if [[ "$gdrc_check" == "" ]]; then common_header "ðŸ’¾  FAILED:  Encrypted Token gd is [INVALID]"
        else
          "ðŸ’¾  FAILED:  Unencrypted Token gd is [INVALID]"
fi; fi; fi; fi; fi
sleep 2
################################################################################

fmt -w 79 "/pg/var/drives/valid.drives" > "/pg/tmp/tokenlist.wrap"
tokenlist=$(cat /pg/tmp/tokenlist.wrap)

touch /pg/var/drives/evalid.drives
fmt -w 79 "/pg/var/drives/evalid.drives" > "/pg/tmp/etokenlist.wrap"
etokenlist=$(cat /pg/tmp/etokenlist.wrap)

if [[ "$etokenlist" == "" ]]; then etokenlist="No Encrypted Tokens Discovered"; fi

common_message "ðŸš€  Rechecking Validity of the Stored Tokens" "
ðŸ’¾ Active Drives: $active_count of $sd_list_track

[UNENCRYPTED]
$tokenlist

[ENCRYPTED]
$etokenlist"; sleep 3

rm -rf /pg/tmp/drives.list
rm -rf /pg/tmp/edrives.list
rm -rf /pg/tmp/drives.bad
rm -rf /pg/tmp/edrives.bad

while read p; do
  equick_check="" && enote=""
  common_header "ðŸ’¾  TESTING: Shared Drive Token(s) for $p"
  quick_check=$(rclone lsd --config /pg/var/drives/shared/$p/$p.conf ${p}: | grep "plexguide.com")
    if [[ -e "/pg/var/drives/e.tokens/$p" ]]; then
    enote=yes
    equick_check=$(rclone lsd --config /pg/var/drives/shared/$p/$p.conf ${p}c: | grep "plexguide.com"); fi

  if [[ "$quick_check" != "" && "$equick_check" == "" && "$enote" != "yes" ]]; then
    common_header "ðŸ’¾  PASSED:  Unencrypted Token $p is valid"; sleep 1
    echo "$p" >> /pg/tmp/drives.list; fi
  if [[ "$quick_check" == "" && "$equick_check" == "" && "$enote" != "yes" ]]; then
    common_header "ðŸ’¾  FAILED:  Unencrypted Token $p is valid"; sleep 1
    echo "$p" >> /pg/tmp/drives.bad; fi

  if [[ "$quick_check" != "" && "$equick_check" != "" && "$enote" == "yes" ]]; then
    common_header "ðŸ’¾  PASSED:  Unencrypted & Encrypted Token $p is valid"
    echo "$p" >> /pg/tmp/drives.list && echo "$p" >> /pg/tmp/edrives.list; sleep 1.5; fi
  if [[ "$quick_check" != "" && "$equick_check" == "" && "$enote" == "yes" ]]; then
    common_header "ðŸ’¾  FAILED:  Encrypted token for $p failed"
    echo "$p" >> /pg/tmp/drives.bad && echo "$p" >> /pg/tmp/edrives.bad; sleep 1.5; fi
done </pg/var/drives/valid.drives




# common_header "âŒ› DEPLOYMENT: Rechecking all VALID Unencrypted Tokens"

# common_header "âŒ› DEPLOYMENT: Service Cleanup & Stopping Docker Containers"; sleep 1.5
# ansible-playbook /pg/mods/drives/ymls/remove.yml

# if [[ "$gdtokeninfo" == "VALID" ]]; then
# common_header "âŒ› DEPLOYMENT: GD Mount"; sleep 1.5; drives_deploy_mounts gd; fi

# if [[ "$gdtokeninfo" == "VALID" && "$gcryptcheck" == "YES" ]]; then
# common_header "âŒ› DEPLOYMENT: GD Crypt Mount"; sleep 1.5; drives_deploy_mounts gc; fi

common_confirm
drives_menu_start && exit
}
